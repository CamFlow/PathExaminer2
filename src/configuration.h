/**
 * @file configuration.h
 * @brief Definition of the Configuration class
 * @author Laurent Georget
 * @version 0.1
 * @date 2016-03-25
 */
#ifndef CONFIGURATION_H
#define CONFIGURATION_H

#include <iostream>
#include <gcc-plugin.h>
#include <tree.h>

#include <memory>
#include <vector>
#include <map>
#include <set>
#include <utility>
#include <limits>
#include <yices.h>

struct Constraint;
class RichBasicBlock;

/**
 * @brief Represents a set of constraints on the variables of an execution path,
 * if the variables are unsatisfiable, then the path is unfeasible
 */
class Configuration
{
	private:
		/**
		 * @brief The set of constraints accumulated so far in the
		 * configuration
		 *
		 * Each constraint is associated with the corresponding term
		 * which can be interpreted by Yices, a SMT solver.
		 */
		std::vector<std::pair<Constraint,term_t>> _constraints;
		/**
		 * @brief A memoization map to record the name assigned to
		 * variables on which constraints are stored
		 */
		static std::map<tree,std::string> _strings;
		/**
		 * @brief A mapping between pointer variables and the variables
		 * they point to, if this information is known unambiguously
		 */
		std::map<tree,tree> _ptrDestination;
		/**
		 * @brief The index of the edge taken to reach the basic block
		 * currently under analysis
		 *
		 * This information is necessary to handle the constraints
		 * generated by the Phi nodes.
		 */
		unsigned int _indexLastEdgeTaken;
		/**
		 * @brief The path followed so far to generate the current
		 * configuration
		 */
		std::vector<RichBasicBlock*> _preds;

		/**
		 * @brief The type of integral values, the only type we know
		 * about
		 */
		const static type_t YICES_INT;

		/**
		 * @brief Handle the case of assignment statements
		 * @param stmt the gimple assignment statement
		 */
		void doGimpleAssign(gimple stmt);
		/**
		 * @brief Handle the case of Phi statements
		 * @param stmt the gimple Phi statement
		 */
		void doGimplePhi(gimple stmt);
		/**
		 * @brief Handle the function calls
		 * @param stmt the gimple call statement
		 */
		void doGimpleCall(gimple stmt);
		/**
		 * @brief Actually adds a constraint to this configuration,
		 * after all care has been taken
		 * @param c the constraint, which is passed by value and then
		 * moved into \a _constraints
		 */
		void doAddConstraint(Constraint c);

	public:
		/**
		 * @brief Builds an empty configuration
		 */
		Configuration();
		/**
		 * @brief Returns the string representing a variable
		 * @param t the variable
		 * @return the string assigned to variable \a t
		 */
		static const std::string& strForTree(tree t);
		/**
		 * @brief Gets a Yices term for a variable or constant
		 * @param t the variable or constraint
		 * @return a Yices named term representing \a t
		 */
		static term_t getNormalizedTerm(tree t);
		/**
		 * @brief Tests whether the configuration is satisfiable
		 * @return true if, and only if, Yices decides that the
		 * conjunction of all constraints in the configuration is
		 * satisfiable
		 */
		explicit operator bool();
		/**
		 * @brief Forget all constraints about the variable passed as
		 * a parameter
		 * @param var a variable
		 */
		void resetVar(tree var);
		/**
		 * @brief Forget all constraints about all the variables that
		 * lives in memory/are aliasable
		 */
		void resetAllVarMem();
		/**
		 * @brief Verifies the validity of a constraint and adds it
		 * @param c a constraint
		 * @return true if, and only if, the constraint can be added
		 * (i.e. it is valid)
		 */
		bool tryAddConstraint(Constraint c);
		/**
		 * @brief Warns this configuration that a new basic block is
		 * being analyzed and updates its internal state
		 *
		 * This method has two purposes. It lets the configuration
		 * maintains a history of the path followed so far and it
		 * updates the information about the edge taken to reach the
		 * basic block.
		 * @param rbb the new basic block under analysis
		 * @param edgeTaken the index of the edge taken to reach the
		 * new basic block (necessary to interpret correctly the
		 * Phi nodes in \a rbb)
		 */
		void setPredecessorInfo(RichBasicBlock* rbb, unsigned int edgeTaken);
		/**
		 * @brief Outputs the path followed to build the current
		 * configuration
		 * @param out the output stream to which the path is to be
		 * printed
		 */
		void printPath(std::ostream& out = std::cout);
		/**
		 * @brief Tests whether a conjunction of constraints is
		 * unsatisfiable
		 * @param terms the constraints to test
		 * @return true if, and only if, the conjunction of all
		 * constraints in \a terms is satisfiable
		 */
		static bool checkVectorOfConstraints(std::vector<term_t>& terms);
		/**
		 * @brief Interpret a gimple statement to add and remove
		 * constraints from this configuration accordingly
		 * @param stmt a gimple statement
		 * @return this configuration itself
		 */
		Configuration& operator<<(gimple stmt);
		/**
		 * @brief Adds a constraint to this configuration if it is valid
		 *
		 * If the configuration is invalid, this is a no-op.
		 * @param c the constraint to add
		 * @return this configuration itself
		 */
		Configuration& operator<<(const Constraint& c);
};


#endif /* ifndef CONFIGURATION_H */
